---
{"dg-publish":true,"dg-path":"Terraform Tips and Tricks.md","permalink":"/terraform-tips-and-tricks/","tags":["notes"]}
---


 - Don't use Counts where possible as they are hard to track, and can lead to Resources being destroyed.
	 - Used named loops where ever possible.
	 - Counts are good for Feature Toggles.
 - Keep everything simple. Terraform is best as Infrastructure as Text.
 - Avoid using Remote State Data blocks, they make managing a pipeline super tricky and are a security issue.
 - Any secret touched by Terraform goes in the state file, remember this and treat the state file as sensitive.
- Read the full name of the resource, and follow it in your file to help understand what is going wrong.
- Terraform has 3 different types of loops
	- `Count` for doing something equal to a length.
	- `for_each` for looping in a resource.
	- `for` for transforming locals.
- `debug` does not do what you want, it only debugs TF application, nothing to do with your code.
- state files are a good lifecycle boundary. If you run a destroy, it should pack up your whole project and nothing more or less.
- ChatGPT and Copilot just don't get it.
- Use Vars for all inputs, Locals for calculations
	- This leads to less places to look for things to change.
- use `EOT` descriptions to make Objects clearer, and to print nice to the CLI inputs and TFdocs
- Use Object based Vars and outputs to give context and a good boundary for description.
	- Grouping by lifecycle. Naming block has all you need for naming, no need to split over 5 places.
- String interpolation is good for simple strings, otherwise `concat()` and `join()` leave more power for it to expand.
- alt click in the shell is handy
	- As well as following references
- Modules are good for building a resource that has a singular lifecycle and intent.
	- If you are struggling to not name a module the resource name, its too simple.
	- If you are just copy / pasting the vars from the module to the root module, it probably shouldn't be a module.
- Modules are not their own entity. Each Resource is measured by itself on the dependency graph.
- Maps are sorted Lexographically, so they have the same constraints as Count based Loops. It is easy to remove the item from the middle and have everything change
- `override.tf` and `.auto.tfvars` make working on plans locally super easy, and great for working on submodules.
	- Mostly for troubleshooting larger projects in a personal scratch environment.
